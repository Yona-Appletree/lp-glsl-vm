# lpc-glsl SSA Review and Fixes

## Current State Analysis

### What's Implemented

- `SSABuilder` with lazy dominance computation (`get_value_at_end_of_block`)
- `BlockInfo` structure for dominance analysis
- Cooper-Harvey-Kennedy dominance algorithm
- Dominance frontier computation for PHI placement
- Basic integration in control flow codegen (partial)

### Critical Issues

1. **Borrow Conflict** (`function/codegen.rs:160-180`)

- `get_ssa_value` can't call `get_value_at_end_of_block` due to Rust borrow checker
- Currently falls back to simple lookup, defeating lazy SSA construction
- Need to restructure to avoid holding `&Function` while mutating `SSABuilder`

2. **Incomplete `find_available_values`** (`codegen/ssa.rs:466-510`)

- Doesn't compute values from predecessors correctly
- Just uses IDom's value instead of computing from all predecessors
- PHI operands aren't properly collected

3. **Incomplete Integration** (`control/codegen.rs`)

- Uses `get_ssa_value` which doesn't actually do lazy SSA
- Falls back to variables map when lazy SSA fails
- Manual phi collection still present as fallback

4. **Unused Code**

- `codegen/value.rs` - GlslValue/GlslLValue/GlslRValue types not used
  - **Migration plan**: See `docs/glsl/05-values.md` for plan to migrate to these types
  - **Reason**: Needed for future struct/array support
  - **Action**: Keep with `#[allow(dead_code)]` until migration
- `codegen/scope.rs` - ScopeStack created but not integrated
- `codegen/loop.rs` - LoopStack created but not integrated
- Various unused imports

5. **Missing Tests**

- `test_nested_control_flow` may fail due to dominance violations
- Need tests for lazy SSA correctness
- Need tests for edge cases (unreachable blocks, single block, etc.)

## Implementation Plan

### Phase 1: Fix Borrow Conflict

**File**: `crates/lpc-glsl/src/function/codegen.rs`

- Restructure `get_ssa_value` to avoid borrow conflict
- Solution: Get function reference in a separate scope, clone necessary data
- Alternative: Pass function reference as parameter instead of accessing via `self.builder()`
- Update `get_value_at_end_of_block` signature if needed to accept function reference

### Phase 2: Complete `find_available_values`

**File**: `crates/lpc-glsl/src/codegen/ssa.rs`

- Fix `find_available_values` to properly compute values from predecessors
- For blocks needing PHIs: collect values from all predecessors (not just IDom)
- For other blocks: use value from IDom (correct)
- Store computed values in `BlockInfo.available_val` for lookup

### Phase 3: Complete Integration

**Files**:

- `crates/lpc-glsl/src/control/codegen.rs`
- `crates/lpc-glsl/src/expr/codegen.rs`

- Remove fallback to variables map in `get_ssa_value` calls
- Ensure all variable reads use lazy SSA construction
- Update control flow codegen to rely on lazy SSA for phi value collection
- Remove manual phi value collection code (keep phi node creation, but get values via lazy SSA)

### Phase 4: Clean Up Unused Code

**Files**:

- `crates/lpc-glsl/src/codegen/mod.rs`
- `crates/lpc-glsl/src/codegen/value.rs` - Keep with `#[allow(dead_code)]` (see `docs/glsl/05-values.md` for migration plan)
- `crates/lpc-glsl/src/codegen/scope.rs` (delete or mark for future use)
- `crates/lpc-glsl/src/codegen/loop.rs` (delete or mark for future use)

- Remove unused imports
- Remove unused exports from `mod.rs` (except value types - keep for future migration)
- Add `#[allow(dead_code)]` to value.rs with reference to migration plan
- Clean up unused imports throughout codebase

### Phase 5: Fix and Add Tests

**Files**:

- `crates/lpc-glsl/tests/complex_tests.rs`
- New: `crates/lpc-glsl/tests/ssa_tests.rs`

- Fix `test_nested_control_flow` if it fails
- Add tests for lazy SSA:
- Simple if/else with variable modification
- Nested control flow
- Loops with variable modification
- Unreachable blocks
- Single block functions
- Multiple definitions in same block
- Verify dominance correctness

### Phase 6: Reference Implementation Review

**Reference**: `/Users/yona/dev/photomancer/DirectXShaderCompiler/include/llvm/Transforms/Utils/SSAUpdaterImpl.h`

- Review `FindAvailableVals` implementation
- Ensure our algorithm matches LLVM's approach
- Verify PHI insertion logic correctness

## Files to Modify

1. `crates/lpc-glsl/src/function/codegen.rs` - Fix borrow conflict
2. `crates/lpc-glsl/src/codegen/ssa.rs` - Complete `find_available_values`
3. `crates/lpc-glsl/src/control/codegen.rs` - Remove fallbacks, use lazy SSA
4. `crates/lpc-glsl/src/expr/codegen.rs` - Ensure uses lazy SSA
5. `crates/lpc-glsl/src/codegen/mod.rs` - Remove unused exports
6. `crates/lpc-glsl/tests/complex_tests.rs` - Fix failing tests
7. `crates/lpc-glsl/tests/ssa_tests.rs` - Add new tests (create file)

## Files to Review for Deletion

- `crates/lpc-glsl/src/codegen/value.rs` - **Keep** (see `docs/glsl/05-values.md` for migration plan)
- `crates/lpc-glsl/src/codegen/scope.rs` - Not used (decision needed)
- `crates/lpc-glsl/src/codegen/loop.rs` - Not used (decision needed)

**Decision**: Keep `value.rs` with `#[allow(dead_code)]` and reference to migration plan. Scope/loop modules need decision.

## Success Criteria

1. All tests pass, including `test_nested_control_flow`
2. No borrow conflicts
3. Lazy SSA construction works correctly for all control flow patterns
4. No unused code warnings
5. Code matches reference implementation approach
6. Proper dominance checking ensures no violations
