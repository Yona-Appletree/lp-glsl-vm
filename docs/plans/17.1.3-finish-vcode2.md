# Complete VCode Support

## Critical Issue: Branch Condition Operands Not Tracked

**Problem**: For conditional branches (`brif`), the condition VReg from `args[0]` is not being recorded as an operand in VCode. This means register allocation won't know about the condition register, which will cause incorrect liveness analysis.

**Location**: `crates/lpc-codegen/src/backend3/lower.rs` lines 238-259

**Current behavior**: When handling `Opcode::Br`, the code extracts target blocks and their arguments but ignores the condition VReg from `args[0]`.

**Solution**: Create a MachInst instruction variant for conditional branches that records the condition operand. This instruction will be a placeholder that gets replaced during emission with actual RISC-V branch instructions (BEQ, BNE, etc.).

## Implementation Tasks

### 1. Add Branch Instruction Variants to Riscv32MachInst

**File**: `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`

- Add `Br` variant for conditional branches:
  ```rust
  Br {
      condition: VReg,
      // Successors and args are stored in VCode branch metadata
  }
  ```

- Add `Jump` variant for unconditional jumps (for consistency, though Jump doesn't need condition):
  ```rust
  Jump {
      // Successors and args are stored in VCode branch metadata
  }
  ```

- Implement `get_operands` for both variants:
  - `Br`: condition is a use operand
  - `Jump`: no operands (unconditional)

### 2. Update Lowering to Create Branch Instructions

**File**: `crates/lpc-codegen/src/backend3/lower.rs`

- In `lower_block()`, when handling `Opcode::Br`:
  - Extract condition VReg from `args[0]`
  - Create `Riscv32MachInst::Br { condition }` instruction
  - Push it to VCode before recording branch metadata
- When handling `Opcode::Jump`:
  - Create `Riscv32MachInst::Jump` instruction
  - Push it to VCode before recording branch metadata

### 3. Add Display Formatting for Branch Instructions

**File**: `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`

- Add `Br` case: format as `br condition` (condition VReg shown)
- Add `Jump` case: format as `jump` (no operands needed in display)
- Note: Branch targets are still displayed separately via VCode branch metadata

### 4. Add Parser Support for Branch Instructions

**File**: `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`

- Add `parse_br` function: parse `br v0` (condition VReg)
- Add `parse_jump` function: parse `jump` (no operands)
- Update `parse_instruction` to include these parsers

### 5. Verify All Instruction Types Are Complete

Review the following instruction types to ensure they're fully implemented:

- ✅ Arithmetic: `iconst`, `iadd`, `isub`, `imul`, `idiv`, `irem` - COMPLETE
- ✅ Comparisons: `icmp` (all condition codes) - COMPLETE
- ✅ Memory: `load`, `store` - COMPLETE
- ✅ Control flow: `return` - COMPLETE
- ⚠️ Control flow: `jump`, `br` - NEED BRANCH INSTRUCTIONS (this plan)
- ✅ System: `call`, `syscall`, `halt`, `trap`, `trapz`, `trapnz` - COMPLETE (per lower.rs)

### 6. Update Tests

**File**: `crates/lpc-codegen/src/backend3/tests/lower_tests.rs`

- Update branch tests to expect branch instructions in VCode output
- Verify condition operands are present in operand collection
- Ensure tests still pass with new branch instruction format

## Files to Modify

1. `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs` - Add Br/Jump variants
2. `crates/lpc-codegen/src/backend3/lower.rs` - Create branch instructions during lowering
3. `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs` - Format branch instructions
4. `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs` - Parse branch instructions
5. `crates/lpc-codegen/src/backend3/tests/lower_tests.rs` - Update test expectations

## Success Criteria

- Conditional branches (`brif`) create `Br` instructions with condition operands
- Unconditional jumps (`jump`) create `Jump` instructions
- Branch condition VRegs are tracked in VCode operand collection
- All existing tests pass with updated branch instruction format
- VCode is complete and ready for register allocation (Phase 2)