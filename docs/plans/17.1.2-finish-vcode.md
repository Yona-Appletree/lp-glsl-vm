# Phase 1: Complete VCode Generation (Updated Scope)

## Critical Understanding

**All VCode generation must be completed in Phase 1** because:

1. **Register allocation (Phase 2) requires complete VCode**:

- Regalloc2 needs all instructions lowered to analyze register usage
- Block structure (successors, predecessors) must be complete
- Branch arguments must be recorded for proper liveness analysis
- Operand information must be complete for all instructions

2. **VCode is the interface between lowering and regalloc**:

- VCode must be self-contained and complete
- Cannot defer instruction lowering to later phases
- Phase 4 focuses on optimization, not initial lowering

## Updated Phase 1 Scope

### Instruction Lowering (Complete)

Phase 1 must lower **all** instruction types needed for basic functions:

#### ✅ Arithmetic Instructions (Implemented)

- `iconst` - Integer constants
- `iadd` - Integer addition
- `isub` - Integer subtraction

#### ✅ Control Flow Instructions (Partially Implemented)

- ✅ `return` - Return from function (IMPLEMENTED)
- ⚠️ `jump` - Unconditional branch to block (HANDLED VIA BRANCH METADATA)
  - Note: Currently handled as VCode branch metadata, not as MachInst instruction
  - Branch information is recorded via `add_branch_args()` in `lower.rs`
  - VCode format displays branches separately from instructions
- ⚠️ `br` - Conditional branch (HANDLED VIA BRANCH METADATA)
  - Note: Currently handled as VCode branch metadata, not as MachInst instruction
  - Branch information is recorded via `add_branch_args()` in `lower.rs`
  - VCode format displays branches separately from instructions

#### ✅ Memory Instructions (Implemented)

- ✅ `load` - Load from memory (IMPLEMENTED)
- ✅ `store` - Store to memory (IMPLEMENTED)
- Lw/Sw MachInst variants exist with operand handling, format, and parser support
- Lowering implementation complete in `lower.rs`

#### ✅ Additional Arithmetic Instructions (Implemented)

- ✅ `imul` - Integer multiply (IMPLEMENTED)
- ✅ `idiv` - Integer divide (IMPLEMENTED)
- ✅ `irem` - Integer remainder (IMPLEMENTED)

#### ✅ Comparison Instructions (Implemented)

- ✅ `icmp` - Integer comparison (IMPLEMENTED)
- Lowered to RISC-V comparison instructions (Slt, Sltiu, Xori)
- Supports all signed comparison condition codes (eq, ne, lt, le, gt, ge)

#### ⚠️ Advanced Instructions (Deferred to Later Phases)

- `call` - Function calls (Phase 4 - requires ABI setup, argument passing)
- `syscall`, `halt`, `trap` - System/trap instructions (later phases)
- `fcmp`, `fconst` - Floating point (deferred if not needed for Phase 1)

## Required Implementation Tasks

### 1. Return Instruction Lowering ✅ COMPLETE

**Status**: Fully implemented

**Implementation**:

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`
  - `Return { ret_vals: Vec<VReg> }` variant exists
  - `get_operands` implemented - return values are uses

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`
  - `Opcode::Return` case implemented in `lower_inst`
  - Extracts return value VRegs from instruction args
  - Creates and pushes `Riscv32MachInst::Return` instruction

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
  - `Return` case in `Display` implementation
  - Format: `return v0` or `return v0, v1` (multi-return)

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
  - Parser for `return` instruction implemented

**Implementation Notes**:

- Return is a terminator (ends block)
- Multi-return support: RISC-V 32 ABI supports up to 2 return values
- Return values are moved to a0/a1 during emission (Phase 3), not lowering

### 2. Jump Instruction Lowering ⚠️ HANDLED VIA BRANCH METADATA

**Status**: Handled as VCode branch metadata (not as MachInst instruction)

**Current Implementation**:

- ✅ `crates/lpc-codegen/src/backend3/lower.rs`
  - `Opcode::Jump` handled in `lower_block()` method
  - Extracts target block and arguments from `block_args`
  - Records branch information via `vcode.add_branch_args()`
  - Branch information stored in VCode's branch structure (block_succs, branch_block_args)

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
  - VCode `Display` implementation formats branches as `br block1` or `br block1(v2, v3)`
  - Branches displayed separately from instructions (after block instructions)

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
  - Parser for `br` instruction exists (`parse_branch()`)
  - Parses target block and optional arguments

**Design Decision**:

- Jump/Br are **not** represented as MachInst instructions
- Instead, they are recorded as VCode branch metadata (control flow structure)
- This is correct because:
  - Branches are control flow, not regular instructions
  - VCode separates instructions from control flow structure
  - Branch information is needed for register allocation (liveness analysis)
  - Actual RISC-V branch instructions (JAL, BEQ, etc.) are emitted during Phase 3 (emission)

**No Further Action Required**: Jump/Br are properly handled via branch metadata

### 3. Br (Conditional Branch) Instruction Lowering ⚠️ HANDLED VIA BRANCH METADATA

**Status**: Handled as VCode branch metadata (not as MachInst instruction)

**Current Implementation**:

- ✅ `crates/lpc-codegen/src/backend3/lower.rs`
  - `Opcode::Br` handled in `lower_block()` method
  - Extracts condition VReg from instruction args
  - Extracts true/false target blocks and their arguments from `block_args`
  - Records both branch targets via `vcode.add_branch_args()`
  - Branch information stored in VCode's branch structure

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
  - VCode `Display` implementation formats branches as `br block1` or `br block1(v2)`
  - Multiple branches displayed for conditional branches (one per successor)

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
  - Parser for branches exists (`parse_branch()`)
  - Can parse multiple branches per block

**Design Decision**:

- Br is **not** represented as a MachInst instruction
- Instead, it is recorded as VCode branch metadata (control flow structure)
- Both successors are recorded in VCode's branch structure
- The condition VReg is tracked as a use operand (though not via MachInst)

**No Further Action Required**: Br is properly handled via branch metadata

### 4. Load Instruction Lowering ✅ COMPLETE

**Status**: Fully implemented

**Implementation**:

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`
  - `Lw` variant exists: `Lw { rd: Writable<VReg>, rs1: VReg, imm: i32 }`
  - `get_operands` implemented

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`
  - `Opcode::Load` case implemented in `lower_inst`
  - Extracts address VReg from instruction args
  - Creates `Riscv32MachInst::Lw` instruction with offset 0
  - Pushes to VCode

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
  - `Lw` Display implemented: `lw v0, 4(v1)`

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
  - `Lw` parser implemented

**Implementation Notes**:
- Load instruction: `load result, address` → `lw result, 0(address)`
- Address is a VReg, offset defaults to 0 (can be extended later for offset support)

### 5. Store Instruction Lowering ✅ COMPLETE

**Status**: Fully implemented

**Implementation**:

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`
  - `Sw` variant exists: `Sw { rs1: VReg, rs2: VReg, imm: i32 }`
  - `get_operands` implemented

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`
  - `Opcode::Store` case implemented in `lower_inst`
  - Extracts value VReg and address VReg from instruction args
  - Creates `Riscv32MachInst::Sw` instruction with offset 0
  - Pushes to VCode

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
  - `Sw` Display implemented: `sw v1, 4(v0)`

- ✅ `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
  - `Sw` parser implemented

**Implementation Notes**:
- Store instruction: `store value, address` → `sw value, 0(address)`
- Value and address are VRegs, offset defaults to 0 (can be extended later for offset support)

### 6. Mul Instruction Lowering (REQUIRED)

**Why**: Complete arithmetic support requires multiply.

**Files to Modify**:

- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`
- Add `Mul { rd: Writable<VReg>, rs1: VReg, rs2: VReg }` variant
- Implement `get_operands` - rd is def, rs1/rs2 are uses

- `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`
- Add `Opcode::Imul` case in `lower_inst`
- Extract operands and result VRegs
- Create `Riscv32MachInst::Mul` instruction
- Push to VCode

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
- Add `Mul` case to `Display` implementation
- Format: `mul v0, v1, v2`

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
- Add parser for `mul` instruction

**Implementation Notes**:
- RISC-V M extension: `mul rd, rs1, rs2`
- Similar to Add/Sub - straightforward arithmetic operation

### 7. Div Instruction Lowering (REQUIRED)

**Why**: Complete arithmetic support requires divide.

**Files to Modify**:

- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`
- Add `Div { rd: Writable<VReg>, rs1: VReg, rs2: VReg }` variant
- Implement `get_operands` - rd is def, rs1/rs2 are uses

- `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`
- Add `Opcode::Idiv` case in `lower_inst`
- Extract operands and result VRegs
- Create `Riscv32MachInst::Div` instruction
- Push to VCode

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
- Add `Div` case to `Display` implementation
- Format: `div v0, v1, v2`

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
- Add parser for `div` instruction

**Implementation Notes**:
- RISC-V M extension: `div rd, rs1, rs2` (signed division)
- Similar to Add/Sub - straightforward arithmetic operation

### 8. Rem Instruction Lowering (REQUIRED)

**Why**: Complete arithmetic support requires remainder.

**Files to Modify**:

- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`
- Add `Rem { rd: Writable<VReg>, rs1: VReg, rs2: VReg }` variant
- Implement `get_operands` - rd is def, rs1/rs2 are uses

- `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`
- Add `Opcode::Irem` case in `lower_inst`
- Extract operands and result VRegs
- Create `Riscv32MachInst::Rem` instruction
- Push to VCode

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
- Add `Rem` case to `Display` implementation
- Format: `rem v0, v1, v2`

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
- Add parser for `rem` instruction

**Implementation Notes**:
- RISC-V M extension: `rem rd, rs1, rs2` (signed remainder)
- Similar to Add/Sub - straightforward arithmetic operation

### 9. Icmp Instruction Lowering (REQUIRED)

**Why**: Conditional branches require comparison results. Icmp produces the condition value used by Br.

**Files to Modify**:

- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`
- Add comparison variants: `Slt`, `Sltu`, `Eq`, `Ne`, etc.
- Or add `Icmp { cond: IntCC, rd: Writable<VReg>, rs1: VReg, rs2: VReg }` variant
- Implement `get_operands` - rd is def, rs1/rs2 are uses
- Note: Comparisons return i32 (0 = false, 1 = true)

- `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`
- Add `Opcode::Icmp { cond }` case in `lower_inst`
- Extract condition code, operands, and result VReg
- Lower to appropriate RISC-V comparison instruction:
  - `eq` → `xor + seqz` (or use `beq`/`bne` pattern)
  - `ne` → `xor + snez`
  - `lt` → `slt`
  - `le` → `slt + xori + seqz` (or sequence)
  - `gt` → `slt` (swapped operands)
  - `ge` → `slt` (swapped) + `xori + seqz`
- Create appropriate `Riscv32MachInst` instruction(s)
- Push to VCode

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_format.rs`
- Add comparison cases to `Display` implementation
- Format: `slt v0, v1, v2` or `icmp eq v0, v1, v2`

- `crates/lpc-codegen/src/isa/riscv32/backend3/vcode_parser.rs`
- Add parser for comparison instructions

**Implementation Notes**:
- Comparisons can be lowered to single instructions (slt, sltu) or sequences
- For `br` instruction, the condition is typically the result of an `icmp`
- RISC-V has: `slt` (signed), `sltu` (unsigned), `slti`, `sltiu`
- Equality comparisons may need `xor` + `seqz`/`snez` pattern

## VCodeBuilder Branch Support

**Status**: Needs verification

**File**: `crates/lpc-codegen/src/backend3/vcode_builder.rs`

**Required Changes**:

- Verify `add_branch()` method exists and works correctly
- Ensure it properly records:
  - Block successors (`block_succs`)
  - Branch arguments (`branch_block_args`)
  - Branch argument ranges (`branch_block_arg_range`)

**Implementation Notes**:
- Branches need to be recorded when blocks end
- The `end_block()` method should check for terminator instructions and record branches
- Or branches can be recorded explicitly via `add_branch()` during lowering

## Lower Context Block Successor Access

**Status**: Needs investigation

**File**: `crates/lpc-codegen/src/backend3/lower.rs`

**Required Changes**:

- Add method to access block successors from IR
- Needed for Jump/Br lowering to determine target blocks
- May need to use `ControlFlowGraph` or `Function` methods

**Implementation Notes**:
- Jump/Br instructions need to know which blocks they target
- This information is in the IR's control flow graph
- May need to add helper methods to `Lower` context

## Implementation Order

1. **Return Instruction** (highest priority - needed for all functions)
2. **Jump Instruction** (needed for multi-block functions)
3. **Br Instruction** (needed for conditional control flow)
4. **Load/Store Instructions** (infrastructure exists, just need lowering)
5. **Mul/Div/Rem Instructions** (complete arithmetic support)
6. **Icmp Instruction** (needed for conditional branches)

## Success Criteria

Phase 1 is complete when:
- ✅ Can lower iconst, iadd, isub instructions
- ✅ Can lower return instructions
- ✅ Can lower jump instructions (for multi-block functions)
- ✅ Can lower br instructions (for conditional control flow)
- ✅ Can lower load/store instructions (for memory access)
- ✅ Can lower imul/idiv/irem instructions (complete arithmetic)
- ✅ Can lower icmp instructions (for comparisons)
- ✅ All instructions appear correctly in VCode text format
- ✅ Tests verify complete function lowering (not just arithmetic)
- ✅ VCode is complete and ready for register allocation (Phase 2)