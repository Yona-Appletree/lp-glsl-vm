# Fix SSA Violations in regalloc2 Integration

## Issues Identified

1. **Small constants don't emit instructions**: Constants <12 bits create VRegs but don't emit instructions, causing SSA violations when used as operands
2. **Entry block parameters need Args instruction**: Function parameters are VRegs that are used but never defined, violating regalloc2's SSA requirements

## Solution Approach (Following Cranelift)

### Issue 1: Small Constants

**Problem**: `materialize_constant` for small constants (<12 bits) only records the constant but doesn't emit an instruction, leaving the VReg undefined.

**Solution** (following Cranelift): Always emit an instruction for constants, even small ones. For small constants, emit `addi vreg, x0, value` using a zero VReg with fixed register constraint.

**Cranelift Reference**: `/Users/yona/dev/photomancer/wasmtime/cranelift/codegen/src/isa/riscv64/inst/mod.rs:129-136`

- Uses `Inst::load_imm12(rd, imm)` which creates `AluRRImm12 { alu_op: Addi, rd, rs: zero_reg(), imm12 }`
- `zero_reg()` returns physical `Reg` (x0), but Cranelift's instructions can reference physical registers directly

**Our Adaptation**: Since our `Addi` takes `rs1: VReg`, we'll use a special zero VReg with `FixedReg` constraint.

**Files to modify**:

- `crates/lpc-codegen/src/backend3/constants.rs`: Update `materialize_constant` to always emit instructions
- `crates/lpc-codegen/src/backend3/vcode_builder.rs`: Add helper to get/create zero VReg
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Handle zero VReg in `get_operands` for `Addi` (use `FixedReg(x0)`)

**Implementation details**:

- Create a zero VReg constant in VCodeBuilder (allocated once, reused)
- For small constants: Emit `Addi { rd: vreg, rs1: zero_vreg, imm: value }`
- In `Addi::get_operands`, if `rs1 == zero_vreg`, use `OperandConstraint::FixedReg(PReg::new(0, RegClass::Int))`
- For large constants: Keep existing LUI+ADDI sequence

### Issue 2: Entry Block Parameters

**Problem**: Entry block parameters (function arguments) are VRegs that are used in instructions but never defined, violating SSA.

**Solution** (following Cranelift): Add an Args instruction at the start of the entry block that defines function parameters with fixed physical registers.

**Cranelift Reference**: `/Users/yona/dev/photomancer/wasmtime/cranelift/codegen/src/isa/riscv64/inst/mod.rs:317-321`

- `Inst::Args { args: Vec<ArgPair> }` where `ArgPair { vreg: VReg, preg: PReg }`
- Uses `collector.reg_fixed_def(vreg, *preg)` in operand collection
- Emits nothing during code emission (pseudo-instruction)

**Files to modify**:

- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Add `Args` variant to `Riscv32MachInst` enum with `args: Vec<ArgPair>`
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Define `ArgPair { vreg: VReg, preg: PReg }`
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Handle Args in `get_operands` using `reg_fixed_def`
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Handle Args in `is_term` (returns `MachTerminator::None`)
- `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`: Emit Args instruction at start of entry block
- `crates/lpc-codegen/src/isa/riscv32/backend3/abi.rs`: Add helper to get ABI argument registers (a0, a1, etc.)
- `crates/lpc-codegen/src/backend3/tests/regalloc_tests.rs`: Remove `#[ignore]` from tests once fixed

**Implementation details**:

- `Args` instruction structure: `Args { args: Vec<ArgPair> }` where `ArgPair { vreg: VReg, preg: PReg }`
- In `get_operands`: For each `ArgPair`, call `collector.reg_fixed_def(vreg, preg)`
- Emit Args as the first instruction in the entry block (before any other instructions)
- Map function parameters to ABI registers: a0 (x10), a1 (x11), a2 (x12), etc. for RISC-V 32
- Args instruction defines all function parameter VRegs with fixed physical registers, satisfying SSA requirements
- During emission: Args is a pseudo-instruction (emits nothing, only constrains registers)

## Implementation Steps

### Step 1: Add Args Instruction (Following Cranelift)

1. **Define ArgPair struct**:

   - Add to `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`:
     ```rust
     #[derive(Debug, Clone)]
     pub struct ArgPair {
         pub vreg: VReg,
         pub preg: regalloc2::PReg,
     }
     ```

2. **Add Args variant to Riscv32MachInst**:

   - Add `Args { args: Vec<ArgPair> }` to the enum

3. **Implement get_operands for Args**:

   - Use `collector.reg_fixed_def(vreg, preg)` for each ArgPair
   - This tells regalloc2 that each VReg must be allocated to the specified physical register

4. **Implement is_term for Args**:

   - Return `MachTerminator::None` (not a terminator)

5. **Add ABI helper for argument registers**:
   - In `crates/lpc-codegen/src/isa/riscv32/backend3/abi.rs`, add function to get argument registers:
     ```rust
     pub fn arg_regs() -> Vec<regalloc2::PReg> {
         // RISC-V 32: a0-a7 (x10-x17)
         (10..=17).map(|n| regalloc2::PReg::new(n, regalloc2::RegClass::Int)).collect()
     }
     ```

### Step 2: Emit Args in Entry Block

1. **Modify lower_block**:
   - In `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`, at the start of `lower_block`:
   - Check if `block == entry_block`
   - If entry block, get function parameters from `func.block_data(entry_block).params`
   - Map each parameter Value to its VReg (from `value_to_vreg`)
   - Create `ArgPair` for each, mapping to ABI argument registers (a0, a1, etc.)
   - Emit `Args` instruction as the very first instruction (before `vcode.start_block()` or immediately after)

### Step 3: Fix Small Constant Materialization (Following Cranelift Pattern)

1. **Add zero VReg helper to VCodeBuilder**:

   - In `crates/lpc-codegen/src/backend3/vcode_builder.rs`:
     - Add field: `zero_vreg: Option<VReg>`
     - Add method: `get_or_create_zero_vreg(&mut self) -> VReg`
     - Allocate zero VReg on first call, reuse afterwards

2. **Modify materialize_constant**:

   - In `crates/lpc-codegen/src/backend3/constants.rs`:
   - For small constants, get zero VReg from vcode
   - Emit `Addi { rd: vreg, rs1: zero_vreg, imm: value }`
   - Always emit an instruction (never just record)

3. **Handle zero VReg in Addi operand collection**:

   - In `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`, in `Addi::get_operands`:
   - Check if `rs1 == zero_vreg` (need to compare against VCode's zero VReg)
   - If yes, use `OperandConstraint::FixedReg(PReg::new(0, RegClass::Int))`
   - Otherwise, use `OperandConstraint::Any`

   **Note**: We need access to VCode's zero VReg in `get_operands`. Options:

   - Store zero VReg in a static/thread-local (not ideal)
   - Pass zero VReg through context (complex)
   - **Simpler**: Store zero VReg index in a constant (e.g., VReg index 0 or MAX), or check if VReg is in constants map with a special marker
   - **Best**: Add a method to VCode to check if a VReg is the zero VReg

4. **Handle zero VReg during emission**:
   - In emission code (future), if `rs1 == zero_vreg`, encode as x0 (register 0)

### Step 4: Update Tests

1. Remove `#[ignore]` from regalloc tests in `crates/lpc-codegen/src/backend3/tests/regalloc_tests.rs`
2. Add test for Args instruction
3. Add test for small constant materialization
4. Verify all tests pass with regalloc2

## Zero Register Handling Details

**Cranelift Approach**: Uses physical `Reg` (x0) directly in instructions. Since our `Addi` takes `VReg`, we adapt:

1. **Create zero VReg**: Allocate a special VReg that represents x0
2. **Fixed constraint**: Use `OperandConstraint::FixedReg(PReg::new(0, RegClass::Int))` for this VReg
3. **Reuse**: Store in VCodeBuilder and reuse across all small constant materializations
4. **Emission**: During code emission, encode zero VReg as x0 (register 0)

**Implementation**:

- Zero VReg is allocated once per VCodeBuilder
- Stored as `Option<VReg>` in VCodeBuilder
- Accessed via `get_or_create_zero_vreg()` method
- In operand collection, check if VReg matches zero VReg and use FixedReg constraint

## Testing

1. **Remove `#[ignore]` from existing regalloc tests**:

   - `test_regalloc_simple`
   - `test_regalloc_multiple_instructions`
   - `test_regalloc_multiple_blocks`
   - `test_regalloc_with_branches`
   - `test_regalloc_with_register_pressure`
   - `test_regalloc_empty_function`
   - `test_regalloc_edits_sorted`
   - `test_regalloc_allocations_valid`
   - `test_regalloc_invalid_ssa_validation`

2. **Add new tests**:

   - Test Args instruction is emitted for entry block
   - Test Args instruction maps parameters to correct registers
   - Test small constant materialization emits Addi
   - Test zero VReg is reused across multiple constants
   - Test zero VReg uses FixedReg constraint

3. **Verify all tests pass**:
   - Run `cargo test --package lpc-codegen regalloc_tests`
   - All tests should pass without `#[ignore]`
