# Fix SSA Violations in regalloc2 Integration

## Issues Identified

1. **Small constants don't emit instructions**: Constants <12 bits create VRegs but don't emit instructions, causing SSA violations when used as operands
2. **Entry block parameters need Args instruction**: Function parameters are VRegs that are used but never defined, violating regalloc2's SSA requirements

## Solution Approach (Following Cranelift)

### Issue 1: Small Constants

**Problem**: `materialize_constant` for small constants (<12 bits) only records the constant but doesn't emit an instruction, leaving the VReg undefined.

**Solution** (following Cranelift): Adopt Cranelift's unified `Reg` type system, then use `zero_reg()` directly in instructions.

**Cranelift Reference**:

- `/Users/yona/dev/photomancer/wasmtime/cranelift/codegen/src/machinst/reg.rs`: Unified `Reg` type with pinned VRegs
- `/Users/yona/dev/photomancer/wasmtime/cranelift/codegen/src/isa/riscv64/inst/mod.rs:129-136`: Uses `Inst::load_imm12(rd, imm)` which creates `AluRRImm12 { alu_op: Addi, rd, rs: zero_reg(), imm12 }`
- `zero_reg()` returns a `Reg` that is a pinned VReg representing x0 (physical register)

**Key Insight**: Cranelift uses a unified `Reg` type that can represent:

- Virtual registers (VRegs) - normal allocatable registers (indices >= 192)
- Physical registers (PRegs) - represented as "pinned" VRegs (indices 0-191)
- Spill slots

**Files to modify**:

- `crates/lpc-codegen/src/backend3/types.rs`: Implement unified `Reg` type (copy/adapt from Cranelift)
- `crates/lpc-codegen/src/backend3/vcode_builder.rs`: Update VReg allocation to start after PINNED_VREGS (192)
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Change instruction definitions from `VReg` to `Reg`
- `crates/lpc-codegen/src/backend3/constants.rs`: Update `materialize_constant` to use `zero_reg()`
- `crates/lpc-codegen/src/isa/riscv32/backend3/regs.rs`: Add `zero_reg()` helper function

**Implementation details**:

- Implement `Reg` type with pinned VReg support (first 192 VReg indices reserved for physical registers)
- For small constants: Emit `Addi { rd: vreg, rs1: zero_reg(), imm: value }` - `zero_reg()` returns `Reg::from_real_reg(PReg::new(0, RegClass::Int))`
- For large constants: Keep existing LUI+ADDI sequence
- Update all instruction definitions: `VReg` → `Reg`, `Writable<VReg>` → `Writable<Reg>`

### Issue 2: Entry Block Parameters

**Problem**: Entry block parameters (function arguments) are VRegs that are used in instructions but never defined, violating SSA.

**Solution** (following Cranelift): Add an Args instruction at the start of the entry block that defines function parameters with fixed physical registers.

**Cranelift Reference**: `/Users/yona/dev/photomancer/wasmtime/cranelift/codegen/src/isa/riscv64/inst/mod.rs:317-321`

- `Inst::Args { args: Vec<ArgPair> }` where `ArgPair { vreg: Reg, preg: PReg }` (after Reg type is implemented)
- Uses `collector.reg_fixed_def(vreg, *preg)` in operand collection
- Emits nothing during code emission (pseudo-instruction)

**Files to modify**:

- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Add `Args` variant to `Riscv32MachInst` enum with `args: Vec<ArgPair>`
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Define `ArgPair { vreg: Reg, preg: PReg }` (uses Reg after Step 3)
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Handle Args in `get_operands` using `reg_fixed_def`
- `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`: Handle Args in `is_term` (returns `MachTerminator::None`)
- `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`: Emit Args instruction at start of entry block
- `crates/lpc-codegen/src/isa/riscv32/backend3/abi.rs`: Add helper to get ABI argument registers (a0, a1, etc.)
- `crates/lpc-codegen/src/backend3/tests/regalloc_tests.rs`: Remove `#[ignore]` from tests once fixed

**Implementation details**:

- `Args` instruction structure: `Args { args: Vec<ArgPair> }` where `ArgPair { vreg: Reg, preg: PReg }` (after Reg type is implemented)
- In `get_operands`: For each `ArgPair`, convert `Reg` to `VReg` using `VReg::from(reg)` and call `collector.reg_fixed_def(vreg, preg)`
- Emit Args as the first instruction in the entry block (before any other instructions)
- Map function parameters to ABI registers: a0 (x10), a1 (x11), a2 (x12), etc. for RISC-V 32
- Args instruction defines all function parameter VRegs with fixed physical registers, satisfying SSA requirements
- During emission: Args is a pseudo-instruction (emits nothing, only constrains registers)

## Implementation Steps

**Note on Step Ordering**: Step 3 (Implement Reg Type) should be done first, as it's foundational. Steps 1 and 2 can reference Reg after Step 3 is complete. Alternatively, implement Args with VReg first, then update to Reg after Step 3.

### Step 1: Add Args Instruction (Following Cranelift)

**Note**: This step assumes Reg type is implemented (Step 3). If implementing in order, do Step 3 first, or use VReg initially and update after Step 3.

1. **Define ArgPair struct**:

   - Add to `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`:
     ```rust
     #[derive(Debug, Clone)]
     pub struct ArgPair {
         pub vreg: Reg,  // Note: Uses Reg, not VReg (after Step 3)
         pub preg: regalloc2::PReg,
     }
     ```

2. **Add Args variant to Riscv32MachInst**:

   - Add `Args { args: Vec<ArgPair> }` to the enum

3. **Implement get_operands for Args**:

   - Use `collector.reg_fixed_def(vreg, preg)` for each ArgPair
   - Convert `Reg` to `VReg` using `VReg::from(reg)` before passing to regalloc2
   - This tells regalloc2 that each VReg must be allocated to the specified physical register

4. **Implement is_term for Args**:

   - Return `MachTerminator::None` (not a terminator)

5. **Add ABI helper for argument registers**:
   - In `crates/lpc-codegen/src/isa/riscv32/backend3/abi.rs`, add function to get argument registers:
     ```rust
     pub fn arg_regs() -> Vec<regalloc2::PReg> {
         // RISC-V 32: a0-a7 (x10-x17)
         (10..=17).map(|n| regalloc2::PReg::new(n, regalloc2::RegClass::Int)).collect()
     }
     ```

### Step 2: Emit Args in Entry Block

1. **Modify lower_block**:
   - In `crates/lpc-codegen/src/isa/riscv32/backend3/lower.rs`, at the start of `lower_block`:
   - Check if `block == entry_block`
   - If entry block, get function parameters from `func.block_data(entry_block).params`
   - Map each parameter Value to its VReg (from `value_to_vreg`)
   - Convert VReg to Reg using `Reg::from_virtual_reg(vreg)`
   - Create `ArgPair` for each, mapping to ABI argument registers (a0, a1, etc.)
   - Emit `Args` instruction as the very first instruction (before `vcode.start_block()` or immediately after)

### Step 3: Implement Unified Reg Type (Following Cranelift)

1. **Implement Reg type** (copy/adapt from Cranelift):

   - In `crates/lpc-codegen/src/backend3/types.rs`:
     - Add `const PINNED_VREGS: usize = 192;` (64 int + 64 float + 64 vec)
     - Implement `Reg` struct: `pub struct Reg(u32);`
     - Implement conversion functions:
       - `Reg::from_virtual_reg(vreg: regalloc2::VReg) -> Reg`
       - `Reg::from_real_reg(preg: regalloc2::PReg) -> Reg`
       - `Reg::to_virtual_reg() -> Option<VirtualReg>`
       - `Reg::to_real_reg() -> Option<RealReg>`
       - `Reg::is_real() -> bool`
       - `Reg::is_virtual() -> bool`
     - Implement `From` conversions between `Reg`, `VReg`, and `PReg`
     - Add helper types: `VirtualReg(VReg)` and `RealReg(PReg)`

2. **Update VReg allocation**:

   - In `crates/lpc-codegen/src/backend3/vcode_builder.rs`:
     - Modify `alloc_vreg()` to start allocating from `PINNED_VREGS` (192) instead of 0
     - Track the next available VReg index starting from 192
     - Ensure we never allocate VRegs in the pinned range (0-191)

3. **Update instruction definitions**:

   - In `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`:
     - Replace all `VReg` with `Reg` in instruction variants
     - Replace all `Writable<VReg>` with `Writable<Reg>`
     - Update `get_operands()` implementations to handle `Reg` type
     - For `Addi`, `rs1` can now be a physical `Reg` (like `zero_reg()`)

4. **Add zero_reg helper**:

   - In `crates/lpc-codegen/src/isa/riscv32/backend3/regs.rs`:
     - Add `pub fn zero_reg() -> Reg { Reg::from_real_reg(PReg::new(0, RegClass::Int)) }`
     - Add `pub fn writable_zero_reg() -> Writable<Reg> { Writable::new(zero_reg()) }`

5. **Update materialize_constant**:

   - In `crates/lpc-codegen/src/backend3/constants.rs`:
     - For small constants, use `zero_reg()` directly: `Addi { rd: vreg, rs1: zero_reg(), imm: value }`
     - Always emit an instruction (never just record)
     - Update function signature to accept `Reg` instead of `VReg` where needed

6. **Update operand collection**:

   - In `crates/lpc-codegen/src/isa/riscv32/backend3/inst.rs`, in `get_operands()`:
     - Convert `Reg` to `VReg` using `VReg::from(reg)`
     - For physical registers (pinned VRegs), regalloc2 will handle them correctly
     - No special handling needed - Cranelift's pinned VReg system handles this automatically

### Step 4: Update Tests

1. Remove `#[ignore]` from regalloc tests in `crates/lpc-codegen/src/backend3/tests/regalloc_tests.rs`
2. Add test for Args instruction
3. Add test for small constant materialization
4. Verify all tests pass with regalloc2

## Unified Reg Type Details (Following Cranelift)

**Cranelift's Approach**: Unified `Reg` type that can represent VRegs, physical registers, and spill slots.

**Key Design**:

1. **Pinned VRegs**: First 192 VReg indices (0-191) are reserved for physical registers
   - Int: 0-63 (64 registers)
   - Float: 64-127 (64 registers)
   - Vector: 128-191 (64 registers)
2. **Regular VRegs**: Allocated starting from index 192
3. **Reg Type**: Wraps VReg internally, but can represent both virtual and physical registers
4. **Zero Register**: `zero_reg()` returns `Reg::from_real_reg(PReg::new(0, RegClass::Int))`, which is a pinned VReg at index 0

**Benefits**:

- Can use physical registers directly in instructions (no special cases)
- Zero register handling is trivial: just use `zero_reg()`
- Aligns perfectly with Cranelift's design
- regalloc2 handles pinned VRegs correctly (they're just VRegs with fixed indices)

**Implementation Notes**:

- `Reg` is a newtype wrapper around `u32` (same as Cranelift)
- Physical registers are represented as pinned VRegs (indices 0-191)
- Conversion between `Reg` and `VReg` is straightforward (just unwrap the u32)
- Operand collection automatically handles pinned VRegs correctly
- No special handling needed for zero register - it's just a pinned VReg at index 0

## Testing

1. **Remove `#[ignore]` from existing regalloc tests**:

   - `test_regalloc_simple`
   - `test_regalloc_multiple_instructions`
   - `test_regalloc_multiple_blocks`
   - `test_regalloc_with_branches`
   - `test_regalloc_with_register_pressure`
   - `test_regalloc_empty_function`
   - `test_regalloc_edits_sorted`
   - `test_regalloc_allocations_valid`
   - `test_regalloc_invalid_ssa_validation`

2. **Add new tests**:

   - Test Args instruction is emitted for entry block
   - Test Args instruction maps parameters to correct registers
   - Test small constant materialization emits Addi with zero_reg()
   - Test Reg type conversions (VReg ↔ Reg ↔ PReg)
   - Test pinned VRegs (physical registers) work correctly
   - Test VReg allocation starts at PINNED_VREGS (192)
   - Test zero_reg() returns correct pinned VReg

3. **Verify all tests pass**:
   - Run `cargo test --package lpc-codegen regalloc_tests`
   - All tests should pass without `#[ignore]`
