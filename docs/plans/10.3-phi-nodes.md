# Full Phi Node Handling Implementation

## Overview

Implement complete phi node handling for block parameters. Since our IR doesn't explicitly list phi sources, we'll infer them by analyzing liveness and handle copies at branch sites (before jumping to successor blocks), following the standard compiler approach.

## Key Insight

**Phi nodes are handled at branch sites, not at block entry.** Before branching to a target block, we copy values from the current block into the target block's parameter registers. This approach:

- Works correctly with multiple predecessors
- Avoids runtime predecessor detection
- Matches how Cranelift and most compilers handle phi nodes

## Architecture

### Phase 1: Infer Phi Sources

Since our IR doesn't explicitly list which values from predecessors feed into block parameters, we need to infer this relationship.

**Algorithm**:

1. For each block with parameters, find all predecessor blocks
2. For each predecessor, find values that are:

   - Live at the end of the predecessor block
   - Used in the successor block (as parameters or in instructions)
   - Match the parameter position/type

3. Build a mapping: `(predecessor_block, param_idx) -> source_value`

**Implementation**: Add `compute_phi_sources()` function in `lower/mod.rs`:

```rust
/// Maps (predecessor_block_idx, target_block_idx, param_idx) -> source_value
type PhiSourceMap = BTreeMap<(usize, usize, usize), Value>;

fn compute_phi_sources(
    func: &Function,
    liveness: &LivenessInfo,
) -> PhiSourceMap {
    // Build predecessor map
    // For each block with params, find predecessors and infer sources
}
```

### Phase 2: Handle Copies at Branch Sites

Before emitting a branch/jump instruction, copy values into the target block's parameter registers.

**Implementation in `lower/branch.rs`**:

1. **Update `lower_jump`**: Before emitting JAL, copy values into target block's parameters
2. **Update `lower_br`**: Before emitting branches, copy values into both target blocks' parameters

**New helper function**: `copy_phi_values()` in `lower/mod.rs`:

```rust
fn copy_phi_values(
    &mut self,
    from_block: usize,
    to_block: usize,
) {
    // Get phi sources for this edge
    // For each parameter of to_block:
    //   - Get source value from from_block
    //   - Get target register (parameter register)
    //   - Copy source -> target (handling spills and parallel copies)
}
```

### Phase 3: Parallel Copy Implementation

When multiple values need to be copied and there are register conflicts (e.g., a->b and b->a), we need parallel copy.

**Algorithm** (simplified cycle-breaking):

1. Build copy list: `(source_reg, target_reg)` pairs
2. Detect cycles (e.g., a->b, b->a)
3. For cycles, use a temporary register to break the cycle
4. Emit copies in correct order

**Implementation**: `emit_parallel_copy()` in `lower/mod.rs`:

```rust
fn emit_parallel_copy(
    &mut self,
    copies: Vec<(Gpr, Gpr)>,
) {
    // Detect cycles
    // Break cycles with temporary register
    // Emit copies
}
```

### Phase 4: Handle Spilled Values

If a source value is spilled, reload it before copying. If a target parameter is spilled, copy to the spill slot.

**Implementation**: Extend `copy_phi_values()` to:

- Check if source is spilled: reload to temporary register, then copy
- Check if target is spilled: copy to spill slot directly

## Implementation Details

### File: `crates/lpc-codegen/src/backend/lower/mod.rs`

**Add fields to `Lowerer`**:

```rust
pub struct Lowerer {
    // ... existing fields ...
    /// Phi source mapping: (pred_block, target_block, param_idx) -> source_value
    phi_sources: PhiSourceMap,
    /// Liveness info (needed for phi source inference)
    liveness: LivenessInfo,
}
```

**Add methods**:

1. `compute_phi_sources()` - Infer phi sources from liveness
2. `copy_phi_values()` - Copy values for a specific edge
3. `emit_parallel_copy()` - Handle parallel copies with cycle breaking
4. `find_predecessors()` - Find all blocks that branch to a given block

**Update `lower_block()`**:

- Remove the TODO comment
- Phi handling now happens at branch sites, not here

### File: `crates/lpc-codegen/src/backend/lower/branch.rs`

**Update `lower_jump()`**:

```rust
pub fn lower_jump(lowerer: &mut Lowerer, target: u32) {
    let current_block = lowerer.current_block_idx(); // Need to track this

    // Copy phi values before jumping
    lowerer.copy_phi_values(current_block, target as usize);

    // Then emit jump as before
    // ...
}
```

**Update `lower_br()`**:

```rust
pub fn lower_br(...) {
    let current_block = lowerer.current_block_idx();

    // Copy phi values for true target (before conditional branch)
    lowerer.copy_phi_values(current_block, target_true as usize);

    // Emit conditional branch
    // ...

    // Copy phi values for false target (before unconditional jump)
    lowerer.copy_phi_values(current_block, target_false as usize);

    // Emit unconditional jump
    // ...
}
```

**Add `current_block_idx` tracking**: Add field to `Lowerer` to track which block we're currently lowering.

### File: `crates/lpc-codegen/src/backend/mod.rs`

**Update `compile_function()`**:

```rust
pub fn compile_function(func: Function) -> InstBuffer {
    let liveness = compute_liveness(&func);
    let allocation = allocate_registers(&func, &liveness);
    let spill_reload = create_spill_reload_plan(&func, &allocation, &liveness);

    // Compute phi sources
    let phi_sources = compute_phi_sources(&func, &liveness);

    // Create lowerer with phi sources
    let mut lowerer = Lowerer::new(
        func,
        allocation,
        spill_reload,
        frame_layout,
        abi,
        liveness,
        phi_sources,
    );

    lowerer.lower_function()
}
```

## Phi Source Inference Algorithm

**Detailed algorithm for `compute_phi_sources()`**:

```rust
fn compute_phi_sources(func: &Function, liveness: &LivenessInfo) -> PhiSourceMap {
    let mut phi_sources = BTreeMap::new();

    // Build predecessor map: target_block -> Vec<predecessor_block>
    let mut predecessors = BTreeMap::new();
    for (pred_idx, block) in func.blocks.iter().enumerate() {
        for inst in &block.insts {
            match inst {
                Inst::Jump { target } => {
                    predecessors.entry(*target as usize)
                        .or_insert_with(Vec::new)
                        .push(pred_idx);
                }
                Inst::Br { target_true, target_false, .. } => {
                    predecessors.entry(*target_true as usize)
                        .or_insert_with(Vec::new)
                        .push(pred_idx);
                    predecessors.entry(*target_false as usize)
                        .or_insert_with(Vec::new)
                        .push(pred_idx);
                }
                _ => {}
            }
        }
    }

    // For each block with parameters
    for (target_idx, target_block) in func.blocks.iter().enumerate() {
        if target_block.params.is_empty() {
            continue;
        }

        if let Some(pred_list) = predecessors.get(&target_idx) {
            for &pred_idx in pred_list {
                let pred_block = &func.blocks[pred_idx];

                // Find values live at end of predecessor
                let pred_end = InstPoint {
                    block: pred_idx,
                    inst: pred_block.insts.len(), // After last instruction
                };
                let live_at_end = liveness.live_sets.get(&pred_end)
                    .cloned()
                    .unwrap_or_default();

                // Match live values to parameters by position
                // Simple heuristic: use values in order they appear in live set
                // Better: match by value ID or by usage in target block
                for (param_idx, param_value) in target_block.params.iter().enumerate() {
                    // Find a value from pred that matches this parameter
                    // For now, use simple matching: find value used in target block
                    // that is live at end of pred
                    if let Some(source_value) = find_matching_value(
                        param_value,
                        &live_at_end,
                        &target_block,
                        liveness,
                    ) {
                        phi_sources.insert((pred_idx, target_idx, param_idx), source_value);
                    }
                }
            }
        }
    }

    phi_sources
}
```

**Note**: The matching algorithm is simplified. A more sophisticated approach would track which values are actually used as which parameters, but for now we can use positional matching or value ID matching.

## Parallel Copy Algorithm

**Cycle detection and breaking**:

```rust
fn emit_parallel_copy(&mut self, copies: Vec<(Gpr, Gpr)>) {
    if copies.is_empty() {
        return;
    }

    // Build dependency graph
    let mut remaining = copies;
    let mut emitted = Vec::new();

    // Simple approach: detect cycles and break them
    while !remaining.is_empty() {
        // Find a copy that doesn't create a cycle
        let mut found_non_cycle = false;
        for i in 0..remaining.len() {
            let (src, dst) = remaining[i];

            // Check if dst is used as src in remaining copies
            let creates_cycle = remaining.iter().any(|(s, _)| *s == dst);

            if !creates_cycle {
                // Safe to emit
                if src != dst {
                    self.inst_buffer_mut().push_add(dst, src, Gpr::Zero);
                }
                emitted.push(remaining.remove(i));
                found_non_cycle = true;
                break;
            }
        }

        if !found_non_cycle {
            // All remaining copies form cycles - break with temp register
            let (src, dst) = remaining.remove(0);
            let temp = self.get_temp_register(); // Use a caller-saved register
            self.inst_buffer_mut().push_add(temp, src, Gpr::Zero);
            self.inst_buffer_mut().push_add(dst, temp, Gpr::Zero);
            emitted.push((src, dst));
        }
    }
}
```

## Testing Strategy

Comprehensive test coverage is critical for phi node handling due to its complexity and critical role in correctness. Tests are organized by component and scenario.

### Unit Tests: Phi Source Inference (`compute_phi_sources`)

**Basic Cases**:

1. **`test_phi_sources_single_predecessor`**: One predecessor, one parameter - verify correct mapping
2. **`test_phi_sources_multiple_predecessors`**: Multiple predecessors, each provides different value
3. **`test_phi_sources_multiple_parameters`**: One predecessor, multiple parameters - verify all mapped
4. **`test_phi_sources_no_predecessors`**: Entry block with parameters (function args) - should be empty map
5. **`test_phi_sources_no_parameters`**: Block with no parameters - should be empty map

**Edge Cases**: 6. **`test_phi_sources_unreachable_block`**: Block with parameters but no predecessors (unreachable) 7. **`test_phi_sources_multiple_live_values`**: Multiple values live at end of predecessor - verify correct one chosen 8. **`test_phi_sources_value_not_live`**: Parameter value not live at end of predecessor - should handle gracefully 9. **`test_phi_sources_self_loop`**: Block that branches to itself - verify self-edge handled 10. **`test_phi_sources_diamond_pattern`**: Diamond CFG pattern (A->B, A->C, B->D, C->D) - verify both paths mapped

**Correctness**: 11. **`test_phi_sources_all_predecessors_covered`**: Every predecessor must provide a value for each parameter 12. **`test_phi_sources_parameter_order`**: Parameters mapped in correct order (param_idx matches) 13. **`test_phi_sources_value_identity`**: Same value from different predecessors maps correctly

### Unit Tests: Copy Phi Values (`copy_phi_values`)

**Basic Cases**:

1. **`test_copy_phi_single_parameter`**: Copy one value from register to register
2. **`test_copy_phi_multiple_parameters`**: Copy multiple values sequentially
3. **`test_copy_phi_no_parameters`**: Block with no parameters - should be no-op
4. **`test_copy_phi_same_register`**: Source and target in same register - should skip copy

**Spilled Values**: 5. **`test_copy_phi_spilled_source`**: Source value spilled - must reload before copy 6. **`test_copy_phi_spilled_target`**: Target parameter spilled - copy directly to slot 7. **`test_copy_phi_both_spilled`**: Both source and target spilled - reload source, store target 8. **`test_copy_phi_spilled_reload_uses_correct_slot`**: Verify reload uses correct spill slot offset

**Register Conflicts**: 9. **`test_copy_phi_source_overwrites_target`**: Copying a->b when b is source for another copy 10. **`test_copy_phi_register_pressure`**: Many copies requiring temporary registers

### Unit Tests: Parallel Copy (`emit_parallel_copy`)

**Basic Cases**:

1. **`test_parallel_copy_single`**: Single copy (no parallelism needed)
2. **`test_parallel_copy_independent`**: Multiple independent copies (a->b, c->d)
3. **`test_parallel_copy_chain`**: Chain of copies (a->b, b->c, c->d) - verify order

**Cycles**: 4. **`test_parallel_copy_cycle_two`**: Simple cycle (a->b, b->a) - verify temp register used 5. **`test_parallel_copy_cycle_three`**: Three-way cycle (a->b, b->c, c->a) - verify broken correctly 6. **`test_parallel_copy_cycle_four`**: Four-way cycle - verify handled 7. **`test_parallel_copy_multiple_cycles`**: Multiple independent cycles - all broken correctly 8. **`test_parallel_copy_cycle_with_chain`**: Cycle plus independent chain - verify both handled

**Edge Cases**: 9. **`test_parallel_copy_empty`**: Empty copy list - should be no-op 10. **`test_parallel_copy_all_same`**: All copies are no-ops (src == dst) - should skip 11. **`test_parallel_copy_temp_register_available`**: Verify temp register doesn't conflict with copies 12. **`test_parallel_copy_temp_register_spilled`**: What if temp register is also spilled? (shouldn't happen, but test)

**Correctness**: 13. **`test_parallel_copy_preserves_values`**: Verify all values correctly copied after parallel copy 14. **`test_parallel_copy_instruction_count`**: Verify minimal instructions emitted (no redundant copies) 15. **`test_parallel_copy_order_independence`**: Result should be same regardless of input order

### Unit Tests: Branch Integration

**Jump Integration**:

1. **`test_jump_with_phi_copy`**: Jump to block with parameters - verify copies emitted before jump
2. **`test_jump_no_phi_copy`**: Jump to block without parameters - no copies emitted
3. **`test_jump_phi_copy_instruction_order`**: Copies must come before jump instruction

**Branch Integration**: 4. **`test_br_true_target_phi_copy`**: Conditional branch true target has parameters - copies before branch 5. **`test_br_false_target_phi_copy`**: Conditional branch false target has parameters - copies before jump 6. **`test_br_both_targets_phi_copy`**: Both targets have parameters - copies for both paths 7. **`test_br_phi_copy_instruction_order`**: Verify correct order: true copies, branch, false copies, jump

### Integration Tests: Control Flow Patterns

**Loops**:

1. **`test_phi_loop_induction_variable`**: Classic loop with induction variable phi (i = phi(0, i+1))
2. **`test_phi_loop_accumulator`**: Loop with accumulator phi (sum = phi(0, sum+x))
3. **`test_phi_loop_nested`**: Nested loops with multiple phis
4. **`test_phi_loop_early_exit`**: Loop with break - phi still works correctly

**Conditionals**: 5. **`test_phi_conditional_merge`**: If-else with phi merge (result = phi(true_val, false_val)) 6. **`test_phi_conditional_nested`**: Nested conditionals with phis 7. **`test_phi_conditional_multiple_merges`**: Multiple independent conditionals merging

**Complex Patterns**: 8. **`test_phi_diamond_pattern`**: Diamond CFG (A->B, A->C, B->D, C->D) with phi at D 9. **`test_phi_multiple_merges`**: Multiple blocks merging into one with multiple phis 10. **`test_phi_irreducible_graph`**: Irreducible CFG (if we support it) - verify phis work 11. **`test_phi_switch_like`**: Multiple branches to same target (switch-like) - all paths provide values

**Real-World Patterns**: 12. **`test_phi_max_function`**: max(a, b) function with phi for result 13. **`test_phi_factorial`**: Factorial function with accumulator phi 14. **`test_phi_fibonacci`**: Fibonacci with multiple phis 15. **`test_phi_while_loop`**: While loop pattern with condition phi

### Integration Tests: Register Allocation Interaction

1. **`test_phi_with_register_pressure`**: Many live values forcing spills - phi copies still work
2. **`test_phi_parameter_spilled`**: Block parameter allocated to spill slot - verify correct handling
3. **`test_phi_source_spilled`**: Source value spilled - verify reload and copy
4. **`test_phi_callee_saved_used`**: Phi copies use callee-saved registers - verify prologue/epilogue correct
5. **`test_phi_register_reuse`**: Same register reused for different phi sources - verify no conflicts

### Integration Tests: End-to-End Execution

**Execution Tests** (using test harness or emulator):

1. **`test_phi_execution_loop`**: Compile and execute loop with phi - verify correct result
2. **`test_phi_execution_conditional`**: Compile and execute conditional with phi - verify both paths
3. **`test_phi_execution_complex`**: Complex function with multiple phis - verify execution correct
4. **`test_phi_execution_spilled`**: Function requiring spills with phis - verify execution correct

### Property-Based Tests

1. **`test_phi_all_predecessors_covered`**: For any valid function, every predecessor provides values for all parameters
2. **`test_phi_no_extra_copies`**: No unnecessary copies (source == target, or value already correct)
3. **`test_phi_copy_preserves_semantics`**: Phi copies preserve program semantics (values correctly propagated)
4. **`test_phi_parallel_copy_idempotent`**: Parallel copy result is deterministic and correct

### Error Cases and Assertions

1. **`test_phi_missing_source_panics`**: Missing phi source for required parameter - should panic with clear message
2. **`test_phi_invalid_block_index`**: Invalid block index in phi source map - should handle gracefully
3. **`test_phi_invalid_value_index`**: Invalid value in phi source - should detect and error

### Performance and Correctness

1. **`test_phi_copy_minimal_instructions`**: Verify minimal number of instructions for phi copies
2. **`test_phi_parallel_copy_efficiency`**: Parallel copy uses minimal temp registers
3. **`test_phi_no_double_copies`**: Values aren't copied twice unnecessarily
4. **`test_phi_copy_doesnt_clobber_live_values`**: Phi copies don't overwrite values still needed

### Test Utilities

**Helper Functions** (in test module):

- `create_phi_test_function()` - Create function with specific phi pattern
- `assert_phi_copies_emitted()` - Verify copies present in instruction stream
- `assert_phi_copy_order()` - Verify copies before branches
- `assert_parallel_copy_correct()` - Verify parallel copy correctness
- `create_function_with_phi()` - Builder for phi test functions

### Test Data

**Test Functions** (IR strings for parser):

```rust
// Loop with induction variable
let loop_ir = r#"
function %test(i32) -> i32 {
block0(v0: i32):
    v1 = iconst 0
    jump block1

block1(v2: i32):  // phi: v2 = phi(v1 from block0, v3 from block1)
    v3 = iadd v2, v0
    brif v3, block1, block2

block2:
    return v2
}"#;

// Conditional merge
let conditional_ir = r#"
function %test(i32) -> i32 {
block0(v0: i32):
    brif v0, block1, block2

block1:
    v1 = iconst 10
    jump block3

block2:
    v2 = iconst 20
    jump block3

block3(v3: i32):  // phi: v3 = phi(v1 from block1, v2 from block2)
    return v3
}"#;
```

### Test Organization

**File Structure**:

```
crates/lpc-codegen/src/backend/tests/
├── phi_tests.rs              # Main phi node tests
│   ├── mod phi_source_tests  # Phi source inference tests
│   ├── mod copy_tests        # Copy phi values tests
│   ├── mod parallel_copy_tests # Parallel copy tests
│   └── mod integration_tests # Integration tests
└── phi_test_helpers.rs       # Test utilities and helpers
```

### Coverage Goals

- **Line Coverage**: >95% for phi-related code
- **Branch Coverage**: >90% for all conditional logic
- **Edge Case Coverage**: All edge cases listed above tested
- **Integration Coverage**: All common control flow patterns tested
- **Execution Coverage**: Critical paths verified with execution tests

### Test Execution Strategy

1. **Unit tests run first** - Fast, isolated tests for each component
2. **Integration tests run second** - Verify components work together
3. **Execution tests run last** - Slowest but most comprehensive
4. **Property-based tests** - Run periodically or in CI, can be slower

### Test Implementation Details

**Testing Phi Source Inference**:

The phi source inference algorithm is critical and tricky. Tests should verify:

1. **Correctness of Inference**:

   - Use IR parser to create test functions with known phi relationships
   - Verify `compute_phi_sources()` returns correct mappings
   - Test with functions where phi sources are unambiguous
   - Test with functions where multiple values are live (verify correct choice)

2. **Inference Algorithm Edge Cases**:

   - Functions where liveness analysis might be ambiguous
   - Functions with dead code (unreachable blocks)
   - Functions with values that are live but not actually used as phi sources
   - Functions where parameter order matters

3. **Inference Failure Cases**:
   - What happens when no matching value found? (should error clearly)
   - What happens when multiple matching values? (should pick deterministically)
   - What happens with malformed IR? (should handle gracefully)

**Testing Parallel Copy**:

Parallel copy correctness is critical - bugs here cause wrong values in registers.

1. **Verify Correctness**:

   - After parallel copy, verify all target registers have correct values
   - Use test harness to execute code and verify results
   - Test with known register assignments (not just "works")

2. **Verify Efficiency**:

   - Count instructions emitted - should be minimal
   - Verify temp registers are caller-saved (don't need saving)
   - Verify no redundant copies

3. **Verify Cycle Breaking**:
   - Test all cycle lengths (2, 3, 4, 5+)
   - Verify cycles are broken correctly (no value loss)
   - Verify temp register doesn't conflict with other copies

**Testing Copy Phi Values**:

1. **Verify Instruction Ordering**:

   - Copies must come before branch/jump instructions
   - Use `InstBuffer` inspection to verify order
   - Test with `assert_asm()` for readable assertions

2. **Verify Spill Handling**:

   - Test all combinations: both in regs, source spilled, target spilled, both spilled
   - Verify correct spill slot offsets used
   - Verify reloads happen before copies, stores after

3. **Verify Edge Cases**:
   - No parameters (should be no-op, no instructions)
   - Same register (should skip copy)
   - Missing phi source (should panic with helpful message)

**Test Assertions**:

Use assembly-based assertions where possible for clarity:

```rust
#[test]
fn test_phi_copy_emitted() {
    let func = create_test_function_with_phi();
    let inst_buffer = compile_function(func);

    // Verify copies are present before jump
    inst_buffer.assert_asm("
        add a1, a0, zero  # phi copy: v1 -> v2
        jal zero, .L1     # jump to block1
    ");
}
```

For more complex cases, inspect `InstBuffer` directly:

```rust
#[test]
fn test_phi_parallel_copy_cycle() {
    let func = create_test_function_with_cycle();
    let inst_buffer = compile_function(func);
    let insts = inst_buffer.instructions();

    // Verify cycle broken with temp register
    assert!(insts.contains_parallel_copy_with_temp());
}
```

**Test Data Generation**:

Create helper functions to generate common phi patterns:

```rust
fn create_loop_with_phi() -> Function { /* ... */ }
fn create_conditional_with_phi() -> Function { /* ... */ }
fn create_diamond_with_phi() -> Function { /* ... */ }
fn create_phi_with_spills() -> Function { /* ... */ }
```

**Debugging Failed Tests**:

When tests fail, provide:

1. The IR function being tested
2. The computed phi source map
3. The emitted instructions (disassembly)
4. Expected vs actual behavior
5. Liveness information (if relevant)

Add `#[cfg(test)]` debug methods to `Lowerer`:

```rust
#[cfg(test)]
impl Lowerer {
    pub fn debug_phi_sources(&self) -> &PhiSourceMap { &self.phi_sources }
    pub fn debug_current_block(&self) -> usize { self.current_block_idx }
}
```

## Implementation Order

**Important**: For this critical and tricky code, use test-driven development. Write tests first, then implement to make them pass.

### Phase 1: Foundation (Tests First)

1. **Write tests for `compute_phi_sources()`**:

   - Start with simple cases (single predecessor, single parameter)
   - Add edge cases (multiple predecessors, no parameters, etc.)
   - **Then implement** `compute_phi_sources()` to pass tests

2. **Write tests for `find_predecessors()`**:

   - Test with various CFG patterns
   - **Then implement** `find_predecessors()`

3. **Add current block tracking**:
   - Add `current_block_idx` field to `Lowerer`
   - Update `lower_block()` to set it
   - Write tests to verify tracking works

### Phase 2: Basic Copy (Tests First)

4. **Write tests for `copy_phi_values()`** (simple case):

   - Single parameter, both in registers
   - Multiple parameters, all in registers
   - No parameters (no-op)
   - **Then implement** `copy_phi_values()` for simple case

5. **Write tests for branch integration**:
   - Jump with phi copy
   - Branch with phi copies for both targets
   - Verify instruction ordering
   - **Then update** `lower_jump()` and `lower_br()`

### Phase 3: Parallel Copy (Tests First)

6. **Write tests for `emit_parallel_copy()`**:

   - Independent copies
   - Two-way cycle
   - Three-way cycle
   - Multiple cycles
   - **Then implement** `emit_parallel_copy()`

7. **Update `copy_phi_values()` to use parallel copy**:
   - Write tests for multiple parameters requiring parallel copy
   - **Then update** implementation

### Phase 4: Spill Handling (Tests First)

8. **Write tests for spilled values**:
   - Source spilled
   - Target spilled
   - Both spilled
   - **Then implement** spill handling in `copy_phi_values()`

### Phase 5: Integration and Edge Cases

9. **Write integration tests**:

   - Loop patterns
   - Conditional patterns
   - Complex CFG patterns
   - **Then fix any issues found**

10. **Write edge case tests**:

    - All edge cases listed in testing strategy
    - **Then ensure all pass**

11. **Write execution tests**:
    - Compile and execute test functions
    - Verify correct results
    - **Then fix any runtime issues**

### Phase 6: Polish

12. **Performance testing**:

    - Verify minimal instructions emitted
    - Verify no redundant copies
    - Optimize if needed

13. **Documentation**:
    - Document phi source inference algorithm
    - Document parallel copy algorithm
    - Add comments to complex code

**Key Principle**: For each feature, write tests first, then implement. This ensures:

- Tests actually test the right thing
- Implementation is testable
- Edge cases are considered upfront
- Bugs are caught early

## Success Criteria

1. Phi nodes with single predecessor work correctly
2. Phi nodes with multiple predecessors work correctly
3. Parallel copies handle cycles correctly
4. Spilled source values are reloaded before copying
5. Spilled target parameters receive values correctly
6. All existing tests still pass
7. New tests for phi handling pass

## Edge Cases

- Block with no parameters (no-op)
- Block with parameters but no predecessors (entry block - parameters are function args)
- Multiple parameters from same predecessor
- Parameter that is never used (dead phi)
- Source value that is constant (should still copy)
- Target parameter in same register as source (no-op copy)

## Notes

- This implementation infers phi sources rather than having them explicit in IR
- Parallel copy uses a simple cycle-breaking algorithm (not optimal but correct)
- We may need to refine the phi source matching algorithm based on test results
- Future optimization: track phi sources explicitly in IR builder for better matching
